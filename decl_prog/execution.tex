\chapter{The execution algorithm}
\label{sec:exec}

\section{Run-time unification}
\label{sec:rt-unify}

The abstract unification algorithm
given in the previous chapter
provides an overall view of the steps involved in
solving unifications.
Since Mercury code is compiled, however,
many of these steps are able to be performed at compile-time
and are thus not necessarily a major concern of the programmer.

In this section we describe the unification steps
that are performed at run-time,
which can be thought of as the residual steps
left over after the compiler has done
as much of the work as possible.
This will allow programmers to get a better understanding of
what kind of processor instructions will be needed,
and how memory will be allocated and accessed.

The residual steps correspond to primitive unifications
involving at most one function symbol,
and which take the form \co{Y = X}
or \co{Y = f(X1, ..., XN)}.
These unifications are categorized further
based on the results of mode analysis,
which can infer either side of the equation
as having mode \co{in}, mode \co{out}, mode \co{unused},
or some other mode.

Four categories of primitive unfications
are compiled into inline code in the target language,
which means they are executed with minimal overhead.
The categories are as follows:
\begin{itemize}
\item
Assignment unifications\label{gi:assignment}.
These are instances of \co{Y = X}
where one of the sides has mode \co{in}
and the other has mode \co{out}.
If \co{Y} is the output variable
then we indicate such unifications as
\co{Y := X}.
\item
Test unifications\label{gi:test}.
These are instances of \co{Y = X}
where both sides have mode \co{in},
and the type is a type constant
(such as \co{int}, for example).
We indicate such unifications as
\co{Y == X}.
\item
Construction unifications\label{gi:construction}.
These are instances of \co{Y = f(X1, ..., XN)}
where \co{Y} has mode \co{out}
and each \co{Xi} has either mode \co{in}
or mode \co{unused}.
We indicate such unifications as
\co{Y := f(X1, ..., XN)}.
\item
Deconstruction unifications\label{gi:deconstruction}.
These are instances of \co{Y = f(X1, ..., XN)}
where \co{Y} has mode \co{in}
and each \co{Xi} has either mode \co{out}
or mode \co{unused}.
We indicate such unifications as
\co{Y == f(X1, ..., XN)}.
\end{itemize}
Other instances of unification
that are permitted by Mercury
are compiled into calls to
out-of-line predicates whose code is
automatically generated by the compiler.

We can write a version of a predicate
with unifications fully expanded
(including head argument unifications).
In a given mode of the predicate,
we can indicate which category
the unification is inferred to be in
using the notation above.

Figure~\ref{fig:forwards-append}
shows how this would look
for the forwards mode of \co{append/3}.
The first clause performs a test on \co{As},
before assigning the value of \co{Bs} to \co{Cs}.
The second clause deconstructs \co{As}
into component arguments,
makes a recursive call,
then constructs \co{Cs} from the result.

\begin{figure}
\begin{verbatim}
    append(As, Bs, Cs) :-
        As == [],
        Cs := Bs.
    append(As, Bs, Cs) :-
        As == [X | As0],
        append(As0, Bs, Cs0),
        Cs := [X | Cs0].
\end{verbatim}
\caption{
The forwards mode of \co{append/3},
with unifications expanded and categorized as
assignments, tests, constructions, and deconstructions.
\label{fig:forwards-append}
}
\end{figure}


\section{Term representation}
\label{sec:term-rep}

Generally speaking,
a value in Mercury occupies a word,
and possibly also an array of words allocated on the heap.
Constants such as integer literals
are stored in the word directly,
whereas for terms built via a data constructor with arity > 0,
the word contains a pointer to the heap array,
which has one word for each argument.

(This is not the whole story.
Some constructor arguments can be packed together
more efficiently than indicated here,
but to a first approximation
this gives a reasonable indication of
how much memory a term requires.)

Data constructors are represented by
primary and/or secondary tag values,
the former of which is stored in the pointer's unused low-bits
and the latter of which is stored on the heap
in an extra array element,
or in the word's high-bits if it does not require a pointer.

The primitive unifications involve the following steps:
\begin{itemize}
\item
For an assignment unification \co{Y := X},
we just need to copy the word from
the location of \co{X} to the location of \co{Y}.
If the word contains a pointer to a heap array,
this array will be shared between both variables.
\item
For a test unification \co{Y == X},
we test the words for equality.
If they are not equal,
and if the words contain pointers to a heap array,
we test that the tags are equal,
and recursively test the arguments.
\item
For a construction unification \co{Y := f(X1, ..., XN)},
we allocate an array on the heap to hold the arguments
and a secondary tag if required.
We then fill in heap slots
for each of the \co{Xi} with mode \co{in},
and the secondary tag if present.
The word representing \co{Y} is the heap pointer,
with a primary tag stored in the low-bits.
\item
For a deconstruction unification \co{Y == f(X1, ..., XN)},
we check that the tags for \co{f/N} are present,
then use the pointer to dereference the heap slots
for each \co{Xi} with mode \co{out}.
\end{itemize}


\section{Switches}
\label{sec:switches}


